/******************************************************************************
 *             Copyright 2020 DeepFrame AI
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#pragma once
#include "Matrix_CUDA.hpp"

namespace julie
{
namespace la
{
namespace cuda
{

/*********************************************************************************
 * This is the abstract base class of all CUDA mode activation functions that do not
 * hold trainable parameters. For example: Sigmoid, ReLU, etc. Activation functions
 * like PReLU that holds alpha as a trainable parameter will not derive from
 * this base class.
 *********************************************************************************/
template <typename DT>
class Activation_CUDA
{
public:

    // Default constructor
    Activation_CUDA() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in) = 0;

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in) = 0;
};

template <typename DT>
class Linear : public Activation_CUDA<DT>
{
public:
    Linear() {};

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};

template <typename DT>
class Sigmoid : public Activation_CUDA<DT>
{
public:
    Sigmoid() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};

template <typename DT>
class TanH : public Activation_CUDA<DT>
{
public:
    TanH() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};

template <typename DT>
class ReLU : public Activation_CUDA<DT>
{
public:
    ReLU() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};


template <typename DT>
class Abs : public Activation_CUDA<DT>
{
public:
    Abs() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};


template <typename DT>
class ArcTan : public Activation_CUDA<DT>
{
public:
    ArcTan() {}

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);
};


template <typename DT>
class SoftMax : public Activation_CUDA<DT>
{
public:

    // SoftMax needs a dimension index (axis) to run with.
    // Size of this dimension indicates numbers classes softmax needs to classify.
    SoftMax(lint axis) : m_axis {axis} {};

    // Forward operation of the activation giving the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     diff:   The derivative d(output) / d(input) generated by this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, Matrix_CUDA<DT> & diff, const Matrix_CUDA<DT> & in);

    // Forward operation of the activation without providing the activation's derivative
    // Arguments:
    //     output: Output of this activation function
    //     in:     Input of this activation function
    // Returns:    void
    virtual void operator () (Matrix_CUDA<DT> & output, const Matrix_CUDA<DT> & in);

private:
    lint m_axis;
};

} // namespace cuda
} // namespace la
} // namespace julie
